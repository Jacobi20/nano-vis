\section{Подсистема моделирования}

Основная задачей подсистемы имитационного моделирования является управление сущностями (создание, обработка и уничтожение, а также их взаимодействие) и настройка параметров окружающей среды. Подсистема сценариев тесно связана с использованием языка программирования Lua \citep{lua}.

%------------------------------------------------------------------
%
%------------------------------------------------------------------

\subsection{Сущности и фабрика сущностей}

Для достижения высокого уровня абстракции и модульности в виртуальном полигоне применяются механизмы наследования и виртуальные функции. Полиморфизм, предоставляющий отложить выбор вызываемой функции (а как следствие --- поведение объектов) на период выполнения программы, обеспечивает повторное использование бинарного кода и его расширение.

Для обеспечения возможности определения типа создаваемого объекта в времени исполнения его необходимо указать. Механизм специализации типа создаваемого объекта называется фабрикой объектов \citep{alexandresku}.

Фабрика позволяет зарегистрировать фабричный метод (функцию создания объекта конкретного класса) и ассоциировать с ним некоторый дескриптор (например, константную строку). Следует отметить, что зарегистрировать фабричный метод можно не только на этапе компиляции, но и на этапе выполнения.

Создать объект заданного класса можно вызвав соответствующий метод фабрики класса и указав дескриптор.
Также, в фабричный метод можно передать дополнительные параметры создания объекта.

В данной реализации виртуального полигона все создаваемые объекты называются \frqt{сущностями} и наследуются от абстрактного класса $\tt entity$.

\begin{lstlisting}[caption={Декларация класса $\tt entity$}]
class entity {
public:
                  entity          ( uint id );
    virtual      ~entity          ( void ) {};
							
    virtual void  spawn           ( lua_State *L, int tidx ) = 0;
    virtual void  think           ( float dtime ) = 0;
    virtual int   command         ( const string &cmd, 
                                    lua_State *L ) = 0;
};
\end{lstlisting}

Сущность должна создаваться, существовать и при этом что-то делать, а также реагировать на внешние события.
В момент создания вызывается метод $\tt spawn$, в который передается указатель на виртуальную машину и индекс таблицы-дескриптора в стеке Lua. Это позволяет создавать объекты путем вызова методов на языке Lua.

На каждом шаге моделирования у каждой созданной сущности вызывается метод $\tt think$, в которые передается время прошедшее с предыдущего шага моделирования.

Для того чтобы взаимодействовать с сущностью используется метод $\tt command$, который можно рассматривать как \frqt{приказ}. В метод $\tt command$ передается строковая команда и указатель на виртуальную машину Lua, что позволяет через стек Lua передать любые параметры. Такой подход обеспечивает возможность отдачи приказов не только из C++ кода, но и из Lua кода.


Центральной компонентой системы имитационного моделирования является фабрика сущностей.
Интерфейс фабрики представлен ниже.

\begin{lstlisting}[caption={Интерфейс фабрики сущностей}]
class factory {
    public:
    factory     ( void );
    ~factory    ( void );

    typedef	entity	*(*create_func)	( uint id );

    void        register_class   ( const string &classname, 
                                   create_func create );
    uint        spawn_entity     ( const string &classname, 
                                   lua_State *L, int tidx );
    void        kill_entity      ( uint id );
    void        kill_all         ( void );
    entity    * get_entity       ( uint id );
    entity    * get_entity       ( const string &name );
};
\end{lstlisting}

Метод $\tt register\_class$ регистрирует класс сущностей, путем ассоциирования имени класса ($\tt classname$) и фабричного метода ($\tt create$).

Метод $\tt spawn\_entity$ порождает сущность класса $\tt classname$. 
Также в функцию передается указатель на виртуальную машину Lua и индекс таблицы-дескриптора, которая может быть использована для параметризации создаваемой сущности.
Метод возвращает уникальный индекс сущности, по которому в дальнейшем к сущности можно обратиться.

Метод $\tt kill\_entity$ --- уничтожает сущность с указанным индексом.

Метод $\tt kill\_all$ --- уничтожает все созданные сущности.

Метод $\tt get\_entity$ --- возвращает указатель на сущность по индексу или по имени.

На данный момент реализована следующая иерархия классов сущностей. См. рис.~\ref{entities}

\begin{figure}[ht]
\begin{center}
\includegraphics[width=110mm]{entities}
\end{center}
\caption{Диаграмма наследования сущностей}
\label{entities}
\end{figure}

%------------------------------------------------------------------
%
%------------------------------------------------------------------

\subsection{Lua API виртуального полигона}

Для обеспечения гибкости и универсальности виртуального полигона используется язык программирования Lua.
Такой подход позволяет создавать сценарии экспериментов \frqt{на ходу} не перезапуская виртуальный полигон.
Для обеспечения работы виртуального полигона, доступа к фабрике сущностей предусмотрены следующие Lua-функции:

\begin{itemize}
\item $\tt scenario.start$ --- запускает сценарий, которые задается 	
\item $\tt scenario.end$ --- завершает сценарий, виртуальный полигон переходит в 
режим ожидания. Никаких процессов моделирования не осуществляется.
\item $\tt scenario.spawn$ --- создает экземпляр сущности заданного класса. Аргументы функции: имя класса сущности и таблица-дескриптор. Возвращает индекс сущности.
\item $\tt scenario.kill$ --- уничтожает сущность с указанным именем или индексом.
\item $\tt scenario.kill\_all$ --- уничтожает все сущности.
\item $\tt scenario.command$ --- транслирует команду сущности заданной по имени или индексу.
\item $\tt scenario.time$ --- возвращает текущее глобальное модельное время.
\item $\tt scenario.set\_gravity$ --- устанавливает уровень гравитации.
\item $\tt scenario.set\_waving$ --- устанавливает параметры морского волнения:
	\begin{itemize}
	\item Частота пика спектра $\omega_{max}$.
	\item Параметр формы углового распределения $m$.
	\item Параметр узости спектра JONSWAP $\gamma$.
	\end{itemize}
\end{itemize}


%------------------------------------------------------------------
%
%------------------------------------------------------------------

\subsection{Объект \frqt{Таймер}}

Важной задачей в процессе моделирования является выполнение той или иной функции в заданный момент времени, или с постоянным интервалом. Для этого реализована сущность \frqt{Таймер}. При создании, таймер получает в качестве параметров:
\begin{itemize}
	\item	Интервал срабатывания --- временной интервал, через который будет вызываться Lua-функция. Если интервал равен $0$, то функция будет вызываться на каждом шаге моделирования.
	\item	Режим работы: однократное срабатывание или многократное.
	\item	Lua-функция для вызова\footnote{В языке Lua функции являются объектами первого класса, и могут быть переданы как параметр в функцию аналогично объекту любого другого типа \citep{implua}}.
\end{itemize}

Пример создания таймера на языке Lua представлен ниже:

\begin{lstlisting}[caption={Пример создания таймера}]
local id1 = scenario.spawn {
    classname   =   "timer";
    period      =   0.250;         
    once        =   false;      
    func        =   function () 
        print("timer function")
    end
}
\end{lstlisting}

Созданный таким образом таймер будет многократно с интервалом 250 мс выводить на консоль текст \frqt{timer function}.

Сам по себе объект таймер является достаточно примитивным и не очень удобным для выполнения различных задач. 
Поэтому для упрощения исследования динамики морских объектов была реализована система задач.

\subsubsection{Реализация системы задач на базе сущности \frqt{Таймер}}
Типовой эксперимент в численном исследовании динамики морского объекта заключается в следующем:
\begin{enumerate}
	\item	Создание судна и формирование параметров окружения 
			(данном случае параметров морского волнения).
	\item	Выполнение на каждом кадре моделирования некоторого действия, например удержание судна 
			в заданной точке.
	\item	Выполнение некоторого действия с заданным интервалом, например запись в журнал текущих							параметров судна
	\item	Уничтожение судна и сброс параметров морского волнения по прошествию некоторого времени. 
			Обычно эксперимент длится от 30 секунд, до 10 минут.
	\item	Вышеперечисленные действия повторяются либо для судна с другими параметрами 
			(например, с измененной нагрузкой или курсом), либо для морского волнения с другими параметрами (например, с другой частотой пика спектра или параметром формы углового распределения).
\end{enumerate}

Под задачей подразумевается совокупность функций, вызов которых должны быть осуществлен в определенные момент времени. В процессе проведения экспериментов были выявлены следующие требования к системе задач.
\begin{enumerate}
	\item Возможность запуска задачи в заданный момент времени.
	\item 	Возможность вызова функции в момент запуска задачи. 
	\item Возможность вызова функции в момент завершения задачи.
	\item Возможность вызова функции с определенным интервалом.
	\item Возможность вызова функции на каждом шаге моделирования.
	\item Возможность параллельного исполнения задач (функции являются атомарными).
	\item Возможность удобного составления расписания.
\end{enumerate}

Реализованная система задач работает следующим образом:
\begin{enumerate}
	\item 	Задаются функции $\tt init\_func$, $\tt term\_func$, $\tt frame\_func$, 
			$\tt tick\_func$? которые будут вызваны соответственно в момент создания задачи, 
			завершения задачи, на каждом шаге моделирования и с заданным интервалом 
			(на каждом \frqt{тике}).
	\item	Задаются время запуска задачи, время работы задачи и интервал между \frqt{тиками}.
	\item 	Создается таймер запуска задачи.
	\item 	В момент срабатывания таймера запуска задачи создается задача. 
			Таймер запуска задачи уничтожается.
	\item 	В момент создания задачи создаются три таймера, каждый из которых отвечает за:
	\begin{enumerate}
	\item	Вызов функции с заданным интервалом.
	\item	Вызов функции на каждом шаге моделирования.
	\item	Завершение задачи.
	\end{enumerate}	 
	\item 	После создания таймеров вызывается функция $\tt init\_func$.
	\item	По завершению задачи вызывается функция $\tt term\_func$ и все 
			таймеры созданные для этой задачи уничтожаются.
\end{enumerate}

Система задач предоставляет две функции:
\begin{itemize}
	\item	$\tt tasks.run()$ - непосредственный запуск задачи. 
			Принимает в качестве параметра Lua-таблицу --- 
			дескриптор задачи, в котором хранятся время выполнения задачи, 
			интервал между \frqt{тиками}, а также функции 
			$\tt init\_func$, $\tt term\_func$, $\tt frame\_func$ 
			и $\tt tick\_func$. Возвращает абсолютное время завершения задачи.
	\item	$\tt tasks.run_at()$ - отложенный запуск задачи. 	
			Принимает время запуска задачи и Lua-таблицу --- дескриптор задачи. 
			Возвращает абсолютное время завершения задачи.
\end{itemize}

Пример составления расписания задач представлен ниже:

\begin{lstlisting}[caption={Пример создания расписания задач}]
local tt1, tt2 = 0, 0;

for i=1, 10 do
  tt1 = tasks.run_at( tt1+1,  x_drift_task(i, 1) );
  tt1 = tasks.run_at( tt1+1,  x_drift_task(i, 2) );
  tt1 = tasks.run_at( tt1+1,  x_drift_task(i, 4) );
  tt1 = tasks.run_at( tt1+1,  x_drift_task(i, 8) );
end

for i=1, 16 do
  tt2 = tasks.run_at( tt2+1,  x_logging_task(i, 1) );
end
\end{lstlisting}

Вышепредставленный листинг демонстрирует создание расписания из 40 последовательно задач $\tt x\_drift\_task$ (функция, которая конструирует дескриптор задачи) и 16 последовательных задач 
$\tt x\_logging\_task$, которые будут выполняться параллельно.

Следует отметить, что система задач реализована полностью на языке Lua, затрагивать C++ код необходимости не было.

%------------------------------------------------------------------
%
%------------------------------------------------------------------

\subsection{Объект \frqt{Корабль}}



