\section{Подсистема моделирования}

Основная задачей подсистемы имитационного моделирования является управление сущностями (создание, обработка и уничтожение, а также их взаимодействие) и настройка параметров окружающей среды. Подсистема сценариев тесно связана с использованием языка программирования Lua \citep{lua}.

%------------------------------------------------------------------
%
%------------------------------------------------------------------

\subsection{Сущности и фабрика сущностей}

Для достижения высокого уровня абстракции и модульности в виртуальном полигоне применяются механизмы наследования и виртуальные функции. Полиморфизм, предоставляющий отложить выбор вызываемой функции (а как следствие --- поведение объектов) на период выполнения программы, обеспечивает повторное использование бинарного кода и его расширение.

Для обеспечения возможности определения типа создаваемого объекта в времени исполнения его необходимо указать. Механизм специализации типа создаваемого объекта называется фабрикой объектов \citep{alexandresku}.

Фабрика позволяет зарегистрировать фабричный метод (функцию создания объекта конкретного класса) и ассоциировать с ним некоторый дескриптор (например, константную строку). Следует отметить, что зарегистрировать фабричный метод можно не только на этапе компиляции, но и на этапе выполнения.

Создать объект заданного класса можно вызвав соответствующий метод фабрики класса и указав дескриптор.
Также, в фабричный метод можно передать дополнительные параметры создания объекта.

В данной реализации виртуального полигона все создаваемые объекты называются \frqt{сущностями} и наследуются от абстрактного класса $\tt entity$.

\begin{lstlisting}[caption={Декларация класса $\tt entity$}]
class entity {
public:
                  entity          ( uint id );
    virtual      ~entity          ( void ) {};
							
    virtual void  spawn           ( lua_State *L, int tidx ) = 0;
    virtual void  think           ( float dtime ) = 0;
    virtual int   command         ( const string &cmd, 
                                    lua_State *L ) = 0;
};
\end{lstlisting}

Сущность должна создаваться, существовать и при этом что-то делать, а также реагировать на внешние события.
В момент создания вызывается метод $\tt spawn$, в который передается указатель на виртуальную машину и индекс таблицы-дескриптора в стеке Lua. Это позволяет создавать объекты путем вызова методов на языке Lua.

На каждом шаге моделирования у каждой созданной сущности вызывается метод $\tt think$, в которые передается время прошедшее с предыдущего шага моделирования.

Для того чтобы взаимодействовать с сущностью используется метод $\tt command$, который можно рассматривать как \frqt{приказ}. В метод $\tt command$ передается строковая команда и указатель на виртуальную машину Lua, что позволяет через стек Lua передать любые параметры. Такой подход обеспечивает возможность отдачи приказов не только из C++ кода, но и из Lua кода.


Центральной компонентой системы имитационного моделирования является фабрика сущностей.
Интерфейс фабрики представлен ниже.

\begin{lstlisting}[caption={Интерфейс фабрики сущностей}]
class factory {
    public:
    factory     ( void );
    ~factory    ( void );

    typedef	entity	*(*create_func)	( uint id );

    void        register_class   ( const string &classname, 
                                   create_func create );
    uint        spawn_entity     ( const string &classname, 
                                   lua_State *L, int tidx );
    void        kill_entity      ( uint id );
    void        kill_all         ( void );
    entity    * get_entity       ( uint id );
    entity    * get_entity       ( const string &name );
};
\end{lstlisting}

Метод $\tt register\_class$ регистрирует класс сущностей, путем ассоциирования имени класса ($\tt classname$) и фабричного метода ($\tt create$).

Метод $\tt spawn\_entity$ порождает сущность класса $\tt classname$. 
Также в функцию передается указатель на виртуальную машину Lua и индекс таблицы-дескриптора, которая может быть использована для параметризации создаваемой сущности.
Метод возвращает уникальный индекс сущности, по которому в дальнейшем к сущности можно обратиться.

Метод $\tt kill\_entity$ --- уничтожает сущность с указанным индексом.

Метод $\tt kill\_all$ --- уничтожает все созданные сущности.

Метод $\tt get\_entity$ --- возвращает указатель на сущность по индексу или по имени.

На данный момент реализована следующая иерархия классов сущностей. См. рис.~\ref{entities}

\begin{figure}[ht]
\begin{center}
\includegraphics[width=110mm]{entities}
\end{center}
\caption{Диаграмма наследования сущностей}
\label{entities}
\end{figure}

%------------------------------------------------------------------
%
%------------------------------------------------------------------

\subsection{Lua API виртуального полигона}

Для обеспечения гибкости и универсальности виртуального полигона используется язык программирования Lua.
Такой подход позволяет создавать сценарии экспериментов \frqt{на ходу} не перезапуская виртуальный полигон.
Для обеспечения работы виртуального полигона, доступа к фабрике сущностей предусмотрены следующие Lua-функции:

\begin{itemize}
\item $\tt scenario.start$ --- запускает сценарий, которые задается 	
\item $\tt scenario.end$ --- завершает сценарий, виртуальный полигон переходит в 
режим ожидания. Никаких процессов моделирования не осуществляется.
\item $\tt scenario.spawn$ --- создает экземпляр сущности заданного класса. Аргументы функции: имя класса сущности и таблица-дескриптор. Возвращает индекс сущности.
\item $\tt scenario.kill$ --- уничтожает сущность с указанным именем или индексом.
\item $\tt scenario.kill\_all$ --- уничтожает все сущности.
\item $\tt scenario.command$ --- транслирует команду сущности заданной по имени или индексу.
\item $\tt scenario.time$ --- возвращает текущее глобальное модельное время.
\item $\tt scenario.set\_gravity$ --- устанавливает уровень гравитации.
\item $\tt scenario.set\_waving$ --- устанавливает параметры морского волнения:
	\begin{itemize}
	\item Частота пика спектра $\omega_{max}$.
	\item Параметр формы углового распределения $m$.
	\item Параметр узости спектра JONSWAP $\gamma$.
	\end{itemize}
\end{itemize}


%------------------------------------------------------------------
%
%------------------------------------------------------------------

\subsection{Объект \frqt{Таймер}}

Важной задачей в процессе моделирования является выполнение той или иной функции в заданный момент времени, или с постоянным интервалом. Для этого реализована сущность \frqt{Таймер}. При создании, таймер получает в качестве параметров:
\begin{itemize}
	\item	Интервал срабатывания --- временной интервал, через который будет вызываться Lua-функция. Если интервал равен $0$, то функция будет вызываться на каждом шаге моделирования.
	\item	Режим работы: однократное срабатывание или многократное.
	\item	Lua-функция для вызова\footnote{В языке Lua функции являются объектами первого класса, и могут быть переданы как параметр в функцию аналогично объекту любого другого типа \citep{implua}}.
\end{itemize}

Пример создания таймера на языке Lua представлен ниже:

\begin{lstlisting}[caption={Пример создания таймера}]
local id1 = scenario.spawn {
    classname   =   "timer";
    period      =   0.250;         
    once        =   false;      
    func        =   function () 
        print("timer function")
    end
}
\end{lstlisting}

Созданный таким образом таймер будет многократно с интервалом 250 мс выводить на консоль текст \frqt{timer function}.

Сам по себе объект таймер является достаточно примитивным и не очень удобным для выполнения различных задач. 
Поэтому для упрощения исследования динамики морских объектов была реализована система задач.

\subsubsection{Реализация системы задач на базе сущности \frqt{Таймер}}
Типовой эксперимент в численном исследовании динамики морского объекта заключается в следующем:
\begin{enumerate}
	\item	Создание судна и формирование параметров окружения 
			(данном случае параметров морского волнения).
	\item	Выполнение на каждом кадре моделирования некоторого действия, например удержание судна 
			в заданной точке.
	\item	Выполнение некоторого действия с заданным интервалом, например запись в журнал текущих							параметров судна
	\item	Уничтожение судна и сброс параметров морского волнения по прошествию некоторого времени. 
			Обычно эксперимент длится от 30 секунд, до 10 минут.
	\item	Вышеперечисленные действия повторяются либо для судна с другими параметрами 
			(например, с измененной нагрузкой или курсом), либо для морского волнения с другими параметрами (например, с другой частотой пика спектра или параметром формы углового распределения).
\end{enumerate}

Под задачей подразумевается совокупность функций, вызов которых должны быть осуществлен в определенные момент времени. В процессе проведения экспериментов были выявлены следующие требования к системе задач.
\begin{enumerate}
	\item Возможность запуска задачи в заданный момент времени.
	\item 	Возможность вызова функции в момент запуска задачи. 
	\item Возможность вызова функции в момент завершения задачи.
	\item Возможность вызова функции с определенным интервалом.
	\item Возможность вызова функции на каждом шаге моделирования.
	\item Возможность параллельного исполнения задач (функции являются атомарными).
	\item Возможность удобного составления расписания.
\end{enumerate}

Реализованная система задач работает следующим образом:
\begin{enumerate}
	\item 	Задаются функции $\tt init\_func$, $\tt term\_func$, $\tt frame\_func$, 
			$\tt tick\_func$? которые будут вызваны соответственно в момент создания задачи, 
			завершения задачи, на каждом шаге моделирования и с заданным интервалом 
			(на каждом \frqt{тике}).
	\item	Задаются время запуска задачи, время работы задачи и интервал между \frqt{тиками}.
	\item 	Создается таймер запуска задачи.
	\item 	В момент срабатывания таймера запуска задачи создается задача. 
			Таймер запуска задачи уничтожается.
	\item 	В момент создания задачи создаются три таймера, каждый из которых отвечает за:
	\begin{enumerate}
	\item	Вызов функции с заданным интервалом.
	\item	Вызов функции на каждом шаге моделирования.
	\item	Завершение задачи.
	\end{enumerate}	 
	\item 	После создания таймеров вызывается функция $\tt init\_func$.
	\item	По завершению задачи вызывается функция $\tt term\_func$ и все 
			таймеры созданные для этой задачи уничтожаются.
\end{enumerate}

Система задач предоставляет две функции:
\begin{itemize}
	\item	$\tt tasks.run()$ - непосредственный запуск задачи. 
			Принимает в качестве параметра Lua-таблицу --- 
			дескриптор задачи, в котором хранятся время выполнения задачи, 
			интервал между \frqt{тиками}, а также функции 
			$\tt init\_func$, $\tt term\_func$, $\tt frame\_func$ 
			и $\tt tick\_func$. Возвращает абсолютное время завершения задачи.
	\item	$\tt tasks.run_at()$ - отложенный запуск задачи. 	
			Принимает время запуска задачи и Lua-таблицу --- дескриптор задачи. 
			Возвращает абсолютное время завершения задачи.
\end{itemize}

Пример составления расписания задач представлен ниже:

\begin{lstlisting}[caption={Пример создания расписания задач}]
local tt1, tt2 = 0, 0;

for i=1, 10 do
  tt1 = tasks.run_at( tt1+1,  x_drift_task(i, 1) );
  tt1 = tasks.run_at( tt1+1,  x_drift_task(i, 2) );
  tt1 = tasks.run_at( tt1+1,  x_drift_task(i, 4) );
  tt1 = tasks.run_at( tt1+1,  x_drift_task(i, 8) );
end

for i=1, 16 do
  tt2 = tasks.run_at( tt2+1,  x_logging_task(i, 1) );
end
\end{lstlisting}

Вышепредставленный листинг демонстрирует создание расписания из 40 последовательно задач $\tt x\_drift\_task$ (функция, которая конструирует дескриптор задачи) и 16 последовательных задач 
$\tt x\_logging\_task$, которые будут выполняться параллельно.

Следует отметить, что система задач реализована полностью на языке Lua, затрагивать C++ код необходимости не было.

%------------------------------------------------------------------
%
%------------------------------------------------------------------

\subsection{Объект \frqt{Корабль}}

Центральным объектом виртуального полигона для задач моделирования экстремальной динамики морских объектов является корабль, который реализован как сущность $\tt ship$. 
Сущность обеспечивает следующие:
\begin{itemize}
	\item	Гибко настраивать параметры судна.
	\item	Осуществлять численное моделирование поведения судна на морском волнении 
			в соответствии с моделью \ref{math_ship} в реальном времени.
	\item 	Визуализировать модель судна, объективно отражая текущее положение судна в пространстве.
	\item	Отправлять команды управления судну.
	\item	Получать текущие параметры судна в последующей возможностью записи в журнал.
\end{itemize}

На данный момент существует возможность задавать следующие атрибуты в момент создания судна:
\begin{itemize}
	\item	Геометрическую модель для расчета гидростатических и гидродинамических сил и моментов.
	\item	Геометрическую модель для расчета момента инерции и отслеживания коллизий.
	\item	Геометрическую модель для визуализации.
	\item	Координаты центра тяжести относительно низшей точки форштевня судна. 
			Задание координат центра тяжести судна позволяет изменять метацентрическую 
			высоту и виртуально менять расположение грузов.
	\item	Поправочный коэффициент к момент инерции. Поправочный коэффициент позволяет 
			виртуально изменить расположение груза на судне.
	\item	Масса судна.
	\item	Общий коэффициент гидродинамического сопротивления.
	\item	Плотность расположения точек при численном интегрировании.
	\item	Коэффициенты масштабирования размеров судна. 
			Позволяет изменить размеры судна сохраняя при этом геометрию формы.
	\item	Расположение абстрактного \frqt{винта} --- точка приложения буксировочной силы.
	\item	Начальное положение ($\mathbf{p}$) в пространстве и текущие углы крена, дифферента и курса($\alpha$, $\beta$, $\gamma$).
\end{itemize}

Геометрические модели, используемые для моделирования динамики судна представлены на рис.~\ref{ship_meshes}.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=150mm]{ship_meshes}
\end{center}
\caption{Полигональные сетки, используемые для моделирования динамики судна. Слева на право: модель для визуализации, модель для гидростатических и гидродинамических расчетов, модель для расчета моментов инерции и коллизий.}
\label{ship_meshes}
\end{figure}



Для задач исследования динамики судна предоставляются следующие команды:
\begin{itemize}
	\item	$\tt set\_propulsion$ --- устанавливает буксировочную силу (в ньютонах) и угол, 
			под которым она приложена
	\item	$\tt get\_dynamics$ --- возвращает Lua-таблицу, в которой находится следующие данные:
	\begin{itemize}
		\item	Суммарные сила и момент, действующие на корабль.
		\item	Текущее положение в пространстве и углы крена, дифферента и курса.
		\item	Текущая скорость.
		\item	Высота волны в точке, где находится центр тяжести судна.
	\end{itemize}
	Хранимые в таблице данные в дальнейшем можно записывать 
	в файл (это позволяет стандартная библиотека Lua) c последующим анализом, 
	в том числе и с использованием пакетов математических программ, таких как Scilab, Matlab и др.
	\item	$\tt update\_forces$ --- обновляет гидростатические и гидродинамические силы
			в соответствии с текущим положением судна и характеристиками морского волнения в точке. 
			Данная команда используется для определения статических характеристик судна, 
			например для построения ДСО.
	\item	$\tt apply\_forces$ --- применяет заданную силу в заданной точке. 
			Данная команда может быть полезна для моделирования периодически возникающих нагрузок, 
			например подъем грузов.
	\item	$\tt set\_pose$ --- форсированно выставляет текущие положение в пространстве 
			и углы крена, дифферента и курса.
	\item	$\tt get\_pose$ --- возвращает текущие положение в пространстве 
			и углы крена, дифферента и курса.
	\item	$\tt show\_forces$ --- показывает распределение сил, действующих на корабль.
\end{itemize}



\subsection{Типовой статический эксперимент: построение ДСО, посадка судна, определение метацентрической высоты.}

Диаграмма статической остойчивости (ДСО, или диаграмма Рида) представляет собой диаграмму зависимости восстанавливающего момента (или плеча момента) от угла крена.
Построение ДСО является типовой задачей при проведении экспериментов по расчету динамики судна на морском волнении.

ДСО строится следующим образом:
\begin{enumerate}
	\item	Параметры волнения выставляются равными 0, что соответствует тихой воде.
	\item	Создается судно с заданными параметрами.
	\item	Судно полностью затапливается (используется команда $\tt set\_pose$).
	\item	Бинарным поиском ищется вертикальная координата судна, 
			при котором вес и выталкивающая сила уравновешиваются (их можно получить, используя команду 
			$\tt get\_dynamics$). 
			Начальное значение момента (равен нулю, если судно не повреждено) и угла крена (равен нулю)
			записываются в файл. Полученная вертикальная координата может также 
			является характеристикой посадки судна на тихую воду.
	\item	Принудительно изменяется угол крена (используется команда $\tt set\_pose$). 
			Бинарным поиском ищется вертикальная координата судна, 
			при котором вес и выталкивающая сила уравновешиваются. 
			Обновляются значения сил действующих на судно (используется команда $\tt update\_forces$).
			Значение момента (равен нулю, если судно не повреждено) и угла крена (равен нулю)
			записываются в файл.
	\item	Шаг №3 повторяется для всего интересующего диапазона углов крена.
	\item	Судно возвращается в исходную точку.
\end{enumerate}

Пример результата расчета ДСО представлен на рис.~\ref{stab_2}. Наличие неровностей на графике ДСО обсуловлено случайностью расположения точек на поверхности корабля. Производная ДСО в нулевой точке соответствует начальной метацентрической высоте.


\begin{figure}[ht]
\begin{center}
\includegraphics[width=130mm]{stab_2}
\end{center}
\caption{Построение ДСО.}
\label{stab_2}
\end{figure}

\subsection{Типовой динамический эксперимент: качка на тихой воде.}

Важнейшей характеристикой судна является частоты собственных колебаний.
Для определения собственных частот колебаний судна, а также определения коэффициентов затухания 
выполняется виртуальное кренование. Для этого необходимо сделать следующие действия:
\begin{enumerate}
	\item	Параметры волнения выставляются равными 0, что соответствует тихой воде.
	\item	Создается судно с заданными параметрами.
	\item	Строится диаграмма бортовой качки:
	\begin{enumerate}
	\item	Величина крена выставляется равной малой не нулевой величине (порядка 5-10 градусов).
	\item	Создается таймер, который через заданный интервал времени остановит процесс
			моделирования (порядка 30--150 секунд, в зависимости от размеров судна).
	\item	Создается таймер, который с заданными интервалом запрашивает текущие 
			характеристики судна. Запись осуществляется с интервалом 0.1--0.5 секунды.
	\end{enumerate}
			
	\item	Строится диаграмма килевой качки:
	\begin{enumerate}
	\item	Величина дифферента выставляется равной малой не нулевой величине (порядка 3-5 градусов).
	\item	Создается таймер, который через заданный интервал времени остановит процесс
			моделирования (порядка 30--150 секунд, в зависимости от размеров судна).
	\item	Создается таймер, который с заданными интервалом запрашивает текущие 
			характеристики судна. Запись осуществляется с интервалом 0.1--0.5 секунды.
	\end{enumerate}
			
	\item	Строится диаграмма вертикальной качки:
	\begin{enumerate}
	\item	Величина возвышения судна выставляется равной малой не нулевой величине (порядка 0.1 осадки).
	\item	Создается таймер, который через заданный интервал времени остановит процесс
			моделирования (порядка 30--150 секунд, в зависимости от размеров судна).
	\item	Создается таймер, который с заданными интервалом запрашивает текущие 
			характеристики судна. Запись осуществляется с интервалом 0.1--0.5 секунды.
	\end{enumerate}
\end{enumerate}

Результаты записи качки, и определения собственных периодов колебаний представлена на рис.~\ref{virtual_rolling}.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=130mm]{rolling}
\includegraphics[width=130mm]{pitching}
\includegraphics[width=130mm]{heaving}
\end{center}
\caption{Результаты виртуального кренования, сверху вниз графики: боротовой, килевой и вертикальной качки.}
\label{virtual_rolling}
\end{figure}



\subsection{Типовой динамический эксперимент: качка на нерегулярном волнении.}

